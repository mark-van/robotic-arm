<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=384rsQkuuLKrqu_E2x74BcV2EQ-W63lfReO-eHo2ASc);.lst-kix_vjacn8cef30-3>li{counter-increment:lst-ctn-kix_vjacn8cef30-3}.lst-kix_51oa0yjksxqn-1>li{counter-increment:lst-ctn-kix_51oa0yjksxqn-1}ol.lst-kix_51oa0yjksxqn-6.start{counter-reset:lst-ctn-kix_51oa0yjksxqn-6 0}.lst-kix_9a9ls9zubsz-1>li:before{content:"\0025cb   "}.lst-kix_ku1xnn35ty4-1>li:before{content:"-  "}ol.lst-kix_vjacn8cef30-7.start{counter-reset:lst-ctn-kix_vjacn8cef30-7 0}.lst-kix_9a9ls9zubsz-0>li:before{content:"\0025cf   "}.lst-kix_ku1xnn35ty4-0>li:before{content:"-  "}.lst-kix_ku1xnn35ty4-5>li:before{content:"-  "}.lst-kix_ku1xnn35ty4-6>li:before{content:"-  "}.lst-kix_ku1xnn35ty4-2>li:before{content:"-  "}ol.lst-kix_vjacn8cef30-1.start{counter-reset:lst-ctn-kix_vjacn8cef30-1 0}.lst-kix_ku1xnn35ty4-3>li:before{content:"-  "}.lst-kix_ku1xnn35ty4-4>li:before{content:"-  "}ol.lst-kix_e359sduypscb-0.start{counter-reset:lst-ctn-kix_e359sduypscb-0 0}ol.lst-kix_51oa0yjksxqn-0.start{counter-reset:lst-ctn-kix_51oa0yjksxqn-0 0}.lst-kix_hd8r9862lpuy-8>li{counter-increment:lst-ctn-kix_hd8r9862lpuy-8}.lst-kix_vjacn8cef30-1>li{counter-increment:lst-ctn-kix_vjacn8cef30-1}ol.lst-kix_hd8r9862lpuy-4.start{counter-reset:lst-ctn-kix_hd8r9862lpuy-4 0}.lst-kix_51oa0yjksxqn-3>li{counter-increment:lst-ctn-kix_51oa0yjksxqn-3}.lst-kix_e359sduypscb-7>li{counter-increment:lst-ctn-kix_e359sduypscb-7}ol.lst-kix_hd8r9862lpuy-5.start{counter-reset:lst-ctn-kix_hd8r9862lpuy-5 0}ol.lst-kix_vjacn8cef30-5{list-style-type:none}ol.lst-kix_vjacn8cef30-4{list-style-type:none}ol.lst-kix_hd8r9862lpuy-0{list-style-type:none}ol.lst-kix_vjacn8cef30-3{list-style-type:none}ol.lst-kix_hd8r9862lpuy-1{list-style-type:none}ol.lst-kix_vjacn8cef30-2{list-style-type:none}ol.lst-kix_hd8r9862lpuy-2{list-style-type:none}ol.lst-kix_51oa0yjksxqn-1.start{counter-reset:lst-ctn-kix_51oa0yjksxqn-1 0}ol.lst-kix_hd8r9862lpuy-3{list-style-type:none}ol.lst-kix_vjacn8cef30-8{list-style-type:none}ol.lst-kix_e359sduypscb-6.start{counter-reset:lst-ctn-kix_e359sduypscb-6 0}ol.lst-kix_hd8r9862lpuy-4{list-style-type:none}ol.lst-kix_vjacn8cef30-7{list-style-type:none}ol.lst-kix_hd8r9862lpuy-5{list-style-type:none}ol.lst-kix_vjacn8cef30-6{list-style-type:none}ol.lst-kix_hd8r9862lpuy-6{list-style-type:none}ol.lst-kix_hd8r9862lpuy-7{list-style-type:none}ol.lst-kix_hd8r9862lpuy-8{list-style-type:none}ol.lst-kix_vjacn8cef30-6.start{counter-reset:lst-ctn-kix_vjacn8cef30-6 0}.lst-kix_vjacn8cef30-7>li{counter-increment:lst-ctn-kix_vjacn8cef30-7}ol.lst-kix_vjacn8cef30-1{list-style-type:none}ol.lst-kix_vjacn8cef30-0{list-style-type:none}.lst-kix_51oa0yjksxqn-8>li{counter-increment:lst-ctn-kix_51oa0yjksxqn-8}ol.lst-kix_e359sduypscb-5.start{counter-reset:lst-ctn-kix_e359sduypscb-5 0}.lst-kix_51oa0yjksxqn-5>li{counter-increment:lst-ctn-kix_51oa0yjksxqn-5}.lst-kix_9a9ls9zubsz-8>li:before{content:"\0025a0   "}.lst-kix_ku1xnn35ty4-7>li:before{content:"-  "}.lst-kix_ku1xnn35ty4-8>li:before{content:"-  "}.lst-kix_9a9ls9zubsz-7>li:before{content:"\0025cb   "}.lst-kix_e359sduypscb-0>li{counter-increment:lst-ctn-kix_e359sduypscb-0}.lst-kix_9a9ls9zubsz-4>li:before{content:"\0025cb   "}.lst-kix_9a9ls9zubsz-6>li:before{content:"\0025cf   "}.lst-kix_9a9ls9zubsz-5>li:before{content:"\0025a0   "}.lst-kix_9a9ls9zubsz-2>li:before{content:"\0025a0   "}.lst-kix_hd8r9862lpuy-6>li{counter-increment:lst-ctn-kix_hd8r9862lpuy-6}.lst-kix_9a9ls9zubsz-3>li:before{content:"\0025cf   "}.lst-kix_51oa0yjksxqn-6>li:before{content:"" counter(lst-ctn-kix_51oa0yjksxqn-6,decimal) ". "}.lst-kix_51oa0yjksxqn-4>li:before{content:"" counter(lst-ctn-kix_51oa0yjksxqn-4,lower-latin) ". "}.lst-kix_51oa0yjksxqn-7>li{counter-increment:lst-ctn-kix_51oa0yjksxqn-7}.lst-kix_51oa0yjksxqn-8>li:before{content:"" counter(lst-ctn-kix_51oa0yjksxqn-8,lower-roman) ". "}.lst-kix_51oa0yjksxqn-2>li:before{content:"" counter(lst-ctn-kix_51oa0yjksxqn-2,lower-roman) ". "}ul.lst-kix_ompmd9xxfu77-5{list-style-type:none}ul.lst-kix_ompmd9xxfu77-4{list-style-type:none}ul.lst-kix_ompmd9xxfu77-3{list-style-type:none}ul.lst-kix_ompmd9xxfu77-2{list-style-type:none}ol.lst-kix_e359sduypscb-1.start{counter-reset:lst-ctn-kix_e359sduypscb-1 0}ul.lst-kix_ompmd9xxfu77-8{list-style-type:none}ul.lst-kix_ompmd9xxfu77-7{list-style-type:none}ul.lst-kix_ompmd9xxfu77-6{list-style-type:none}ul.lst-kix_ku1xnn35ty4-0{list-style-type:none}.lst-kix_vjacn8cef30-6>li:before{content:"" counter(lst-ctn-kix_vjacn8cef30-6,decimal) ". "}.lst-kix_yxr45t4lxl7e-6>li:before{content:"-  "}ul.lst-kix_ku1xnn35ty4-4{list-style-type:none}ul.lst-kix_ku1xnn35ty4-3{list-style-type:none}ul.lst-kix_ku1xnn35ty4-2{list-style-type:none}ol.lst-kix_e359sduypscb-4.start{counter-reset:lst-ctn-kix_e359sduypscb-4 0}ul.lst-kix_ku1xnn35ty4-1{list-style-type:none}ul.lst-kix_ku1xnn35ty4-8{list-style-type:none}ul.lst-kix_ku1xnn35ty4-7{list-style-type:none}.lst-kix_vjacn8cef30-8>li:before{content:"" counter(lst-ctn-kix_vjacn8cef30-8,lower-roman) ". "}ul.lst-kix_ku1xnn35ty4-6{list-style-type:none}.lst-kix_yxr45t4lxl7e-8>li:before{content:"-  "}ul.lst-kix_ku1xnn35ty4-5{list-style-type:none}ol.lst-kix_hd8r9862lpuy-8.start{counter-reset:lst-ctn-kix_hd8r9862lpuy-8 0}.lst-kix_vjacn8cef30-4>li:before{content:"" counter(lst-ctn-kix_vjacn8cef30-4,lower-latin) ". "}.lst-kix_yxr45t4lxl7e-4>li:before{content:"-  "}.lst-kix_51oa0yjksxqn-0>li:before{content:"" counter(lst-ctn-kix_51oa0yjksxqn-0,decimal) ". "}ol.lst-kix_51oa0yjksxqn-4.start{counter-reset:lst-ctn-kix_51oa0yjksxqn-4 0}.lst-kix_e359sduypscb-4>li{counter-increment:lst-ctn-kix_e359sduypscb-4}.lst-kix_vjacn8cef30-0>li:before{content:"" counter(lst-ctn-kix_vjacn8cef30-0,decimal) ". "}.lst-kix_vjacn8cef30-2>li:before{content:"" counter(lst-ctn-kix_vjacn8cef30-2,lower-roman) ". "}.lst-kix_yxr45t4lxl7e-0>li:before{content:"-  "}.lst-kix_yxr45t4lxl7e-2>li:before{content:"-  "}.lst-kix_51oa0yjksxqn-6>li{counter-increment:lst-ctn-kix_51oa0yjksxqn-6}ol.lst-kix_51oa0yjksxqn-7.start{counter-reset:lst-ctn-kix_51oa0yjksxqn-7 0}ol.lst-kix_e359sduypscb-0{list-style-type:none}.lst-kix_hd8r9862lpuy-4>li{counter-increment:lst-ctn-kix_hd8r9862lpuy-4}ol.lst-kix_e359sduypscb-1{list-style-type:none}.lst-kix_e359sduypscb-2>li:before{content:"" counter(lst-ctn-kix_e359sduypscb-2,lower-roman) ". "}.lst-kix_e359sduypscb-4>li:before{content:"" counter(lst-ctn-kix_e359sduypscb-4,lower-latin) ". "}ol.lst-kix_e359sduypscb-4{list-style-type:none}ol.lst-kix_e359sduypscb-5{list-style-type:none}ol.lst-kix_e359sduypscb-2{list-style-type:none}ol.lst-kix_e359sduypscb-3{list-style-type:none}ol.lst-kix_e359sduypscb-8{list-style-type:none}.lst-kix_e359sduypscb-0>li:before{content:"" counter(lst-ctn-kix_e359sduypscb-0,decimal) ". "}ol.lst-kix_e359sduypscb-6{list-style-type:none}.lst-kix_e359sduypscb-8>li:before{content:"" counter(lst-ctn-kix_e359sduypscb-8,lower-roman) ". "}ol.lst-kix_e359sduypscb-7{list-style-type:none}.lst-kix_7bjao5kx6gky-7>li:before{content:"\0025cb   "}ol.lst-kix_e359sduypscb-2.start{counter-reset:lst-ctn-kix_e359sduypscb-2 0}ol.lst-kix_vjacn8cef30-8.start{counter-reset:lst-ctn-kix_vjacn8cef30-8 0}.lst-kix_e359sduypscb-5>li{counter-increment:lst-ctn-kix_e359sduypscb-5}.lst-kix_ohlumywgk74p-8>li:before{content:"\0025a0   "}.lst-kix_ohlumywgk74p-6>li:before{content:"\0025cf   "}.lst-kix_ohlumywgk74p-4>li:before{content:"\0025cb   "}ol.lst-kix_51oa0yjksxqn-5.start{counter-reset:lst-ctn-kix_51oa0yjksxqn-5 0}.lst-kix_ohlumywgk74p-0>li:before{content:"\0025cf   "}.lst-kix_ohlumywgk74p-2>li:before{content:"\0025a0   "}.lst-kix_7bjao5kx6gky-1>li:before{content:"\0025cb   "}.lst-kix_7bjao5kx6gky-5>li:before{content:"\0025a0   "}.lst-kix_e359sduypscb-6>li:before{content:"" counter(lst-ctn-kix_e359sduypscb-6,decimal) ". "}.lst-kix_vjacn8cef30-5>li{counter-increment:lst-ctn-kix_vjacn8cef30-5}.lst-kix_7bjao5kx6gky-3>li:before{content:"\0025cf   "}ul.lst-kix_7bjao5kx6gky-2{list-style-type:none}ul.lst-kix_7bjao5kx6gky-1{list-style-type:none}ul.lst-kix_7bjao5kx6gky-4{list-style-type:none}ul.lst-kix_7bjao5kx6gky-3{list-style-type:none}.lst-kix_hd8r9862lpuy-7>li{counter-increment:lst-ctn-kix_hd8r9862lpuy-7}ul.lst-kix_7bjao5kx6gky-0{list-style-type:none}ul.lst-kix_7bjao5kx6gky-6{list-style-type:none}.lst-kix_ompmd9xxfu77-1>li:before{content:"\0025cb   "}ul.lst-kix_7bjao5kx6gky-5{list-style-type:none}ul.lst-kix_7bjao5kx6gky-8{list-style-type:none}.lst-kix_ompmd9xxfu77-2>li:before{content:"\0025a0   "}ul.lst-kix_7bjao5kx6gky-7{list-style-type:none}.lst-kix_hd8r9862lpuy-2>li:before{content:"" counter(lst-ctn-kix_hd8r9862lpuy-2,lower-roman) ". "}.lst-kix_hd8r9862lpuy-1>li:before{content:"" counter(lst-ctn-kix_hd8r9862lpuy-1,lower-latin) ". "}.lst-kix_hd8r9862lpuy-3>li:before{content:"" counter(lst-ctn-kix_hd8r9862lpuy-3,decimal) ". "}ul.lst-kix_ohlumywgk74p-8{list-style-type:none}ol.lst-kix_51oa0yjksxqn-3.start{counter-reset:lst-ctn-kix_51oa0yjksxqn-3 0}ul.lst-kix_ohlumywgk74p-7{list-style-type:none}ul.lst-kix_ohlumywgk74p-6{list-style-type:none}ul.lst-kix_ohlumywgk74p-5{list-style-type:none}ul.lst-kix_ohlumywgk74p-4{list-style-type:none}ul.lst-kix_yxr45t4lxl7e-7{list-style-type:none}.lst-kix_ompmd9xxfu77-0>li:before{content:"\0025cf   "}ul.lst-kix_ohlumywgk74p-3{list-style-type:none}ol.lst-kix_vjacn8cef30-4.start{counter-reset:lst-ctn-kix_vjacn8cef30-4 0}ul.lst-kix_yxr45t4lxl7e-8{list-style-type:none}ul.lst-kix_ohlumywgk74p-2{list-style-type:none}ul.lst-kix_ohlumywgk74p-1{list-style-type:none}ol.lst-kix_hd8r9862lpuy-7.start{counter-reset:lst-ctn-kix_hd8r9862lpuy-7 0}ul.lst-kix_ohlumywgk74p-0{list-style-type:none}.lst-kix_hd8r9862lpuy-0>li:before{content:"" counter(lst-ctn-kix_hd8r9862lpuy-0,decimal) ". "}.lst-kix_ompmd9xxfu77-8>li:before{content:"\0025a0   "}ul.lst-kix_yxr45t4lxl7e-5{list-style-type:none}.lst-kix_hd8r9862lpuy-5>li{counter-increment:lst-ctn-kix_hd8r9862lpuy-5}ul.lst-kix_yxr45t4lxl7e-6{list-style-type:none}.lst-kix_vjacn8cef30-4>li{counter-increment:lst-ctn-kix_vjacn8cef30-4}ul.lst-kix_yxr45t4lxl7e-3{list-style-type:none}ul.lst-kix_yxr45t4lxl7e-4{list-style-type:none}ul.lst-kix_yxr45t4lxl7e-1{list-style-type:none}ul.lst-kix_yxr45t4lxl7e-2{list-style-type:none}ul.lst-kix_yxr45t4lxl7e-0{list-style-type:none}.lst-kix_ompmd9xxfu77-3>li:before{content:"\0025cf   "}ol.lst-kix_hd8r9862lpuy-1.start{counter-reset:lst-ctn-kix_hd8r9862lpuy-1 0}.lst-kix_51oa0yjksxqn-0>li{counter-increment:lst-ctn-kix_51oa0yjksxqn-0}.lst-kix_ompmd9xxfu77-4>li:before{content:"\0025cb   "}.lst-kix_ompmd9xxfu77-7>li:before{content:"\0025cb   "}.lst-kix_ompmd9xxfu77-5>li:before{content:"\0025a0   "}ol.lst-kix_e359sduypscb-3.start{counter-reset:lst-ctn-kix_e359sduypscb-3 0}.lst-kix_ompmd9xxfu77-6>li:before{content:"\0025cf   "}.lst-kix_vjacn8cef30-0>li{counter-increment:lst-ctn-kix_vjacn8cef30-0}.lst-kix_vjacn8cef30-6>li{counter-increment:lst-ctn-kix_vjacn8cef30-6}.lst-kix_e359sduypscb-6>li{counter-increment:lst-ctn-kix_e359sduypscb-6}ol.lst-kix_51oa0yjksxqn-8.start{counter-reset:lst-ctn-kix_51oa0yjksxqn-8 0}.lst-kix_hd8r9862lpuy-6>li:before{content:"" counter(lst-ctn-kix_hd8r9862lpuy-6,decimal) ". "}.lst-kix_hd8r9862lpuy-0>li{counter-increment:lst-ctn-kix_hd8r9862lpuy-0}.lst-kix_hd8r9862lpuy-5>li:before{content:"" counter(lst-ctn-kix_hd8r9862lpuy-5,lower-roman) ". "}.lst-kix_hd8r9862lpuy-4>li:before{content:"" counter(lst-ctn-kix_hd8r9862lpuy-4,lower-latin) ". "}.lst-kix_51oa0yjksxqn-2>li{counter-increment:lst-ctn-kix_51oa0yjksxqn-2}ol.lst-kix_vjacn8cef30-5.start{counter-reset:lst-ctn-kix_vjacn8cef30-5 0}ul.lst-kix_ompmd9xxfu77-1{list-style-type:none}.lst-kix_hd8r9862lpuy-3>li{counter-increment:lst-ctn-kix_hd8r9862lpuy-3}ul.lst-kix_ompmd9xxfu77-0{list-style-type:none}.lst-kix_hd8r9862lpuy-7>li:before{content:"" counter(lst-ctn-kix_hd8r9862lpuy-7,lower-latin) ". "}ol.lst-kix_51oa0yjksxqn-2.start{counter-reset:lst-ctn-kix_51oa0yjksxqn-2 0}.lst-kix_hd8r9862lpuy-8>li:before{content:"" counter(lst-ctn-kix_hd8r9862lpuy-8,lower-roman) ". "}ol.lst-kix_hd8r9862lpuy-6.start{counter-reset:lst-ctn-kix_hd8r9862lpuy-6 0}.lst-kix_hd8r9862lpuy-1>li{counter-increment:lst-ctn-kix_hd8r9862lpuy-1}ul.lst-kix_9a9ls9zubsz-4{list-style-type:none}ul.lst-kix_9a9ls9zubsz-5{list-style-type:none}.lst-kix_51oa0yjksxqn-5>li:before{content:"" counter(lst-ctn-kix_51oa0yjksxqn-5,lower-roman) ". "}.lst-kix_51oa0yjksxqn-7>li:before{content:"" counter(lst-ctn-kix_51oa0yjksxqn-7,lower-latin) ". "}ul.lst-kix_9a9ls9zubsz-6{list-style-type:none}ul.lst-kix_9a9ls9zubsz-7{list-style-type:none}ul.lst-kix_9a9ls9zubsz-8{list-style-type:none}ol.lst-kix_hd8r9862lpuy-0.start{counter-reset:lst-ctn-kix_hd8r9862lpuy-0 0}.lst-kix_51oa0yjksxqn-1>li:before{content:"" counter(lst-ctn-kix_51oa0yjksxqn-1,lower-latin) ". "}.lst-kix_51oa0yjksxqn-3>li:before{content:"" counter(lst-ctn-kix_51oa0yjksxqn-3,decimal) ". "}.lst-kix_e359sduypscb-3>li{counter-increment:lst-ctn-kix_e359sduypscb-3}ul.lst-kix_9a9ls9zubsz-0{list-style-type:none}ul.lst-kix_9a9ls9zubsz-1{list-style-type:none}ul.lst-kix_9a9ls9zubsz-2{list-style-type:none}.lst-kix_yxr45t4lxl7e-5>li:before{content:"-  "}ul.lst-kix_9a9ls9zubsz-3{list-style-type:none}.lst-kix_vjacn8cef30-5>li:before{content:"" counter(lst-ctn-kix_vjacn8cef30-5,lower-roman) ". "}.lst-kix_vjacn8cef30-7>li:before{content:"" counter(lst-ctn-kix_vjacn8cef30-7,lower-latin) ". "}.lst-kix_yxr45t4lxl7e-7>li:before{content:"-  "}ol.lst-kix_e359sduypscb-7.start{counter-reset:lst-ctn-kix_e359sduypscb-7 0}.lst-kix_hd8r9862lpuy-2>li{counter-increment:lst-ctn-kix_hd8r9862lpuy-2}ol.lst-kix_vjacn8cef30-3.start{counter-reset:lst-ctn-kix_vjacn8cef30-3 0}.lst-kix_vjacn8cef30-3>li:before{content:"" counter(lst-ctn-kix_vjacn8cef30-3,decimal) ". "}.lst-kix_e359sduypscb-1>li{counter-increment:lst-ctn-kix_e359sduypscb-1}.lst-kix_yxr45t4lxl7e-3>li:before{content:"-  "}ol.lst-kix_vjacn8cef30-0.start{counter-reset:lst-ctn-kix_vjacn8cef30-0 0}.lst-kix_vjacn8cef30-1>li:before{content:"" counter(lst-ctn-kix_vjacn8cef30-1,lower-latin) ". "}.lst-kix_yxr45t4lxl7e-1>li:before{content:"-  "}ol.lst-kix_vjacn8cef30-2.start{counter-reset:lst-ctn-kix_vjacn8cef30-2 0}.lst-kix_e359sduypscb-3>li:before{content:"" counter(lst-ctn-kix_e359sduypscb-3,decimal) ". "}.lst-kix_7bjao5kx6gky-8>li:before{content:"\0025a0   "}.lst-kix_51oa0yjksxqn-4>li{counter-increment:lst-ctn-kix_51oa0yjksxqn-4}.lst-kix_7bjao5kx6gky-6>li:before{content:"\0025cf   "}.lst-kix_e359sduypscb-7>li:before{content:"" counter(lst-ctn-kix_e359sduypscb-7,lower-latin) ". "}.lst-kix_e359sduypscb-1>li:before{content:"" counter(lst-ctn-kix_e359sduypscb-1,lower-latin) ". "}ol.lst-kix_hd8r9862lpuy-2.start{counter-reset:lst-ctn-kix_hd8r9862lpuy-2 0}.lst-kix_ohlumywgk74p-7>li:before{content:"\0025cb   "}.lst-kix_e359sduypscb-8>li{counter-increment:lst-ctn-kix_e359sduypscb-8}.lst-kix_e359sduypscb-2>li{counter-increment:lst-ctn-kix_e359sduypscb-2}.lst-kix_ohlumywgk74p-3>li:before{content:"\0025cf   "}.lst-kix_ohlumywgk74p-5>li:before{content:"\0025a0   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_7bjao5kx6gky-2>li:before{content:"\0025a0   "}.lst-kix_7bjao5kx6gky-0>li:before{content:"\0025cf   "}.lst-kix_7bjao5kx6gky-4>li:before{content:"\0025cb   "}ol.lst-kix_51oa0yjksxqn-7{list-style-type:none}.lst-kix_vjacn8cef30-8>li{counter-increment:lst-ctn-kix_vjacn8cef30-8}ol.lst-kix_51oa0yjksxqn-8{list-style-type:none}ol.lst-kix_51oa0yjksxqn-5{list-style-type:none}ol.lst-kix_hd8r9862lpuy-3.start{counter-reset:lst-ctn-kix_hd8r9862lpuy-3 0}ol.lst-kix_51oa0yjksxqn-6{list-style-type:none}ol.lst-kix_e359sduypscb-8.start{counter-reset:lst-ctn-kix_e359sduypscb-8 0}ol.lst-kix_51oa0yjksxqn-3{list-style-type:none}ol.lst-kix_51oa0yjksxqn-4{list-style-type:none}.lst-kix_vjacn8cef30-2>li{counter-increment:lst-ctn-kix_vjacn8cef30-2}ol.lst-kix_51oa0yjksxqn-1{list-style-type:none}ol.lst-kix_51oa0yjksxqn-2{list-style-type:none}.lst-kix_e359sduypscb-5>li:before{content:"" counter(lst-ctn-kix_e359sduypscb-5,lower-roman) ". "}.lst-kix_ohlumywgk74p-1>li:before{content:"\0025cb   "}ol.lst-kix_51oa0yjksxqn-0{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c30{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#d9d9d9;border-top-width:1pt;border-right-width:1pt;border-left-color:#d9d9d9;vertical-align:middle;border-right-color:#d9d9d9;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:72pt;border-top-color:#d9d9d9;border-bottom-style:solid}.c18{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c51{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#d9d9d9;border-top-width:1pt;border-right-width:1pt;border-left-color:#d9d9d9;vertical-align:middle;border-right-color:#d9d9d9;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:69pt;border-top-color:#d9d9d9;border-bottom-style:solid}.c47{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#ffffff;border-top-width:1pt;border-right-width:1pt;border-left-color:#ffffff;vertical-align:top;border-right-color:#ffffff;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:234pt;border-top-color:#ffffff;border-bottom-style:solid}.c44{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#d9d9d9;border-top-width:1pt;border-right-width:1pt;border-left-color:#d9d9d9;vertical-align:middle;border-right-color:#d9d9d9;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:75pt;border-top-color:#d9d9d9;border-bottom-style:solid}.c56{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#f3f3f3;border-top-width:1pt;border-right-width:1pt;border-left-color:#f3f3f3;vertical-align:middle;border-right-color:#f3f3f3;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:215.2pt;border-top-color:#f3f3f3;border-bottom-style:solid}.c77{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#f3f3f3;border-top-width:1pt;border-right-width:1pt;border-left-color:#f3f3f3;vertical-align:middle;border-right-color:#f3f3f3;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:123.8pt;border-top-color:#f3f3f3;border-bottom-style:solid}.c48{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#f3f3f3;border-top-width:1pt;border-right-width:1pt;border-left-color:#f3f3f3;vertical-align:middle;border-right-color:#f3f3f3;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:92.2pt;border-top-color:#f3f3f3;border-bottom-style:solid}.c37{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#d9d9d9;border-top-width:1pt;border-right-width:1pt;border-left-color:#d9d9d9;vertical-align:middle;border-right-color:#d9d9d9;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:216pt;border-top-color:#d9d9d9;border-bottom-style:solid}.c7{-webkit-text-decoration-skip:none;color:#1155cc;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Arial";font-style:normal}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c0{padding-top:14pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c61{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c17{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Consolas";font-style:normal}.c73{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c58{padding-top:10pt;padding-bottom:0pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Consolas";font-style:normal}.c65{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Jost";font-style:normal}.c26{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Jost";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Jost";font-style:normal}.c15{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c31{font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Jost";font-style:normal}.c20{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:right}.c2{-webkit-text-decoration-skip:none;color:#3c4043;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-family:"Jost"}.c14{padding-top:0pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c75{padding-top:10pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c59{padding-top:0pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c10{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;font-weight:400;text-decoration:underline}.c32{color:#666666;text-decoration:none;vertical-align:baseline;font-size:12pt;font-style:normal}.c23{color:#000000;text-decoration:none;vertical-align:baseline;font-size:9pt;font-style:normal}.c21{color:#000000;text-decoration:none;vertical-align:baseline;font-size:12pt;font-style:normal}.c54{color:#000000;font-weight:400;font-size:16pt;font-family:"Arial"}.c49{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c52{padding-top:0pt;padding-bottom:10pt;line-height:1.15;text-align:left}.c41{padding-top:0pt;padding-bottom:10pt;line-height:1.0;text-align:center}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c46{color:#000000;font-weight:400;font-size:10pt;font-family:"Consolas"}.c34{padding-top:3pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c22{border-spacing:0;border-collapse:collapse;margin-right:auto}.c78{font-weight:700;text-decoration:none;vertical-align:baseline;font-family:"Arial"}.c24{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c67{font-size:10pt;font-family:"Consolas";color:#008013;font-weight:400}.c16{font-size:10pt;font-family:"Consolas";color:#0e00ff;font-weight:400}.c43{font-size:8pt;font-family:"Consolas";color:#666666;font-weight:400}.c36{text-decoration:none;vertical-align:baseline;font-style:normal}.c66{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c68{font-size:10pt;font-family:"Consolas";font-weight:400}.c69{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c62{color:#000000;font-weight:400;font-family:"Arial"}.c71{border-spacing:0;border-collapse:collapse;margin-right:auto}.c38{color:#666666;font-size:15pt}.c33{color:inherit;text-decoration:inherit}.c57{color:#434343;font-size:14pt}.c5{font-weight:400;font-family:"Jost"}.c60{color:#000000;font-size:16pt}.c27{padding:0;margin:0}.c70{color:#000000;font-size:26pt}.c42{font-family:"Jost";font-weight:700}.c64{margin-left:72pt}.c40{height:0pt}.c76{color:#000000}.c19{height:11pt}.c55{margin-left:18pt}.c29{font-style:italic}.c25{margin-left:36pt}.c72{font-family:"Consolas"}.c13{vertical-align:sub}.c28{padding-left:0pt}.c53{font-size:12pt}.c63{font-size:8pt}.c45{font-size:11pt}.c74{font-family:"Jost"}.c50{text-indent:36pt}.c39{vertical-align:super}.c35{background-color:#f3f3f3}.c8{color:#3c4043}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c69 doc-content"><div><p class="c11"><span class="c36 c45 c62"></span></p></div><p class="c73 title" id="h.b6dya0fzt0j0"><span class="c36 c42 c70">Yamaha YK500XGP Design Project</span></p><p class="c58 subtitle" id="h.oobpqwhuuziu"><span class="c42">Software</span><span class="c36 c5 c38">&nbsp;Whitepaper</span></p><p class="c75"><span class="c42">M. Van Genderen, </span><span class="c1">C. Hansen, S. Sidorov</span></p><p class="c75"><span class="c5">Faculty of Electrical &amp; Computer Engineering</span><span class="c1">, University of British Columbia</span></p><hr><p class="c11"><span class="c1"></span></p><h2 class="c61" id="h.u3huw5o6124n"><span class="c36 c5 c60">Abstract</span></h2><p class="c14"><span class="c5">A SCARA robotic arm was developed, based on the Yamaha YK500XGP design. Our SCARA was designed with simplicity and affordability as priorities, as this team plans to physically build the designed arm in the future. Our SCARA arm will draw shapes in its region of operation. While simple, it leaves a lot of room for expansion of the idea. For a basic demonstration of this capability, hardcoding a shape to draw would work as a proof of concept. From this proof of concept, it&rsquo;s relatively straightforward to extend the system to reading from text files, to reading from a phone app via Wifi or Bluetooth, for example.</span></p><p class="c34"><span class="c10"><a class="c33" href="#h.u3huw5o6124n">Abstract</a></span></p><p class="c34"><span class="c10"><a class="c33" href="#h.1mytz5lydtw1">Software</a></span></p><p class="c34 c55"><span class="c49"><a class="c33" href="#h.p8r7oq2iz15e">Controller Design</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.dj56jz5hiynk">O2 Amp</a></span></p><p class="c25 c34"><span class="c49"><a class="c33" href="#h.yjk96uo7eq0r">Motor and Gears</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.pz9awwn9zjcr">Sensor</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.w5giwshktbq8">Control Frequency Calculations</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.mj4gsm6v825">Sensor Filter</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.ypg6n15eekp">Derivative Filter</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.2qt7ddhe2h5f">10-Step Process</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.581b4n1l5bcl">Heuristic Tuning</a></span></p><p class="c34 c55"><span class="c49"><a class="c33" href="#h.s0dvmgz3jcs4">Actuator Design</a></span></p><p class="c34 c55"><span class="c49"><a class="c33" href="#h.ts3vfealse2h">Code</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.gomn93q0pp5g">Homing Logic:</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.ve8anxdx1nz4">Sensor Logic</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.2xru8hvmsgav">Kinematics</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.1h1m5nak3g7k">Path Planning</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.6wekgcczbt8u">Self-Documentation</a></span></p><p class="c34 c25"><span class="c49"><a class="c33" href="#h.gmavmdei0vrc">Testing</a></span></p><p class="c34"><span class="c10"><a class="c33" href="#h.h1ttglahnbly">References:</a></span></p><p class="c34"><span class="c10"><a class="c33" href="#h.rwontong3yw6">Appendix:</a></span></p><p class="c14 c19"><span class="c1"></span></p><h2 class="c61" id="h.1mytz5lydtw1"><span class="c36 c5 c60">Software</span></h2><p class="c14"><span class="c5">The following is a report on the </span><span class="c5 c29">Software</span><span class="c1">&nbsp;part of the project, which includes the design of our actuators and controller, as well as all the C code we wrote for this project. &nbsp;</span></p><h3 class="c65" id="h.p8r7oq2iz15e"><span class="c36 c57 c5">Controller Design</span></h3><p class="c15"><span class="c42">Table 1: Controller RCGs</span></p><a id="t.222823139ad68047adcaad79936dc836d2a07583"></a><a id="t.0"></a><table class="c24"><tr class="c40"><td class="c37 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Property</span></p></td><td class="c30 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Requirement</span></p></td><td class="c51 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Constraint</span></p></td><td class="c35 c44" colspan="1" rowspan="1"><p class="c9"><span class="c26">Goal</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c41"><span class="c1">Rise Time</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c41"><span class="c1">&ndash;</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c41"><span class="c1">&ndash;</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c41"><span class="c1">&lt; 1 s</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c41"><span class="c1">Motor Speed</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c5 c53">&gt; 0.5 rad/s</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c41"><span class="c1">&ndash;</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c41"><span class="c5 c53">3 rad/s</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c41"><span class="c1">Percentage Overshoot</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c5">&ndash;</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c41"><span class="c1">&ndash;</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c41"><span class="c21 c5">&lt;3%</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c41"><span class="c1">&nbsp;Settle Time </span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c5">&ndash;</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c41"><span class="c1">&ndash;</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c41"><span class="c5 c21">&lt; 0.5 s</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><h4 class="c0" id="h.dj56jz5hiynk"><span class="c32 c5">O2 Amp</span></h4><p class="c15"><span class="c1">We designed second order transfer functions to approximate our op amp. Settlement time, rise time, and peak time values from the real amplifier&rsquo;s step response were used to approximate the second order transfer function. We used the best possible approximation which did not destabilize our system (Plot labeled Tuned) as our model. The matlab code producing this graph and containing our op amp calculations can be found in the appendix.</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 337.00px; height: 272.87px;"><img alt="" src="images/image25.png" style="width: 337.00px; height: 272.87px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c3">Figure 1: Amplitude TF Step Responses</span></p><p class="c11"><span class="c1"></span></p><h4 class="c0" id="h.yjk96uo7eq0r"><span class="c32 c5">Motor and Gears</span></h4><p class="c15"><span class="c1">We used the standard motor transfer function for this project as shown below:</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 467.50px; height: 161.83px;"><img alt="" src="images/image18.png" style="width: 467.50px; height: 161.83px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c3">Figure 2: The Motor Feedback Circuit</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 517.00px; height: 136.83px;"><img alt="" src="images/image16.png" style="width: 517.00px; height: 136.83px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c3">Figure 3: The Motor TF Circuit (Including a Gear Ratio)</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">We&rsquo;re using the low speed version of the mechanical transfer function, and therefore must multiply the torque by the gear ratio before entering the mechanical TF (since the torque is greater on the higher gear side of the gearbox). In the feedback loop we must multiply by the gear ratio to account for the increased speed on the low gear side of the gearbox. The values shown in the diagram above are listed in the actuator section of this report.</span></p><h4 class="c0" id="h.pz9awwn9zjcr"><span class="c32 c5">Sensor</span></h4><p class="c14"><span class="c1">Our sensor has a resolution of 1024 and our microcontroller can only read whole values. The resolution represents how many times the counter will increment per complete revolution of the motor. Therefore, we can convert from radians to our resolution&#39;s interpretation of that angle by multiplying by 1023/(2&pi;). Since our microcontroller will only read whole numbers of this value, we must either floor or ceiling this value. Finally we multiply by the inverse to maintain unity gain for the sensor.</span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 295.00px; height: 63.00px;"><img alt="" src="images/image39.png" style="width: 295.00px; height: 63.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c3">Figure 4: Model of Sensor in Simulink</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 341.16px;"><img alt="" src="images/image14.png" style="width: 480.00px; height: 341.16px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c42">Figure 5: Before and After Roof Block. Yellow-&gt;before,Blue -&gt; after </span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 310.89px;"><img alt="" src="images/image27.png" style="width: 480.00px; height: 310.89px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c42">Figure 6: Before and After Floor Block. Yellow-&gt;before,Blue -&gt; after</span></p><h4 class="c0" id="h.w5giwshktbq8"><span class="c32 c5">Control Frequency Calculations</span></h4><p class="c4"><span class="c1">In order to calculate the control frequency (CF), we use a ESP32 emulator and perform the following:</span></p><p class="c4 c19"><span class="c1"></span></p><ul class="c27 lst-kix_ompmd9xxfu77-0 start"><li class="c4 c25 c28 li-bullet-0"><span class="c5">Store the value of a ESP32 timer which is automatically started when the </span><span class="c5">microcontroller </span><span class="c1">runs (by calling micros() function)</span></li><li class="c4 c25 c28 li-bullet-0"><span class="c5">Loop ISR </span><span class="c5 c29">n</span><span class="c1">&nbsp;times (where n is greater than a thousand)</span></li><li class="c4 c25 c28 li-bullet-0"><span class="c1">Once again, retrieve the microcontroller&rsquo;s relative time</span></li><li class="c4 c25 c28 li-bullet-0"><span class="c1">The difference in time between the previous time measurements is an approximation of the average time to complete the ISR + time to run additional code(ie. micros() and for loop)</span></li><li class="c4 c25 c28 li-bullet-0"><span class="c1">Run a separate program to approximate the time to complete this additional code, find average ISR time, and multiply by 2 to avoid incomplete ISR calls</span></li></ul><p class="c4 c19"><span class="c1"></span></p><p class="c14"><span class="c1">For 100000 iterations we compute a find a total execution time of 36527335 microseconds, and we find that the time to run additional code is about 5 microseconds: </span></p><p class="c59"><img src="images/image1.png"><span class="c1">&nbsp;</span></p><p class="c14"><span class="c1">Therefore our control frequency is: </span></p><p class="c59"><img src="images/image2.png"></p><h4 class="c0" id="h.mj4gsm6v825"><span class="c5">Sensor Filter</span></h4><p class="c11"><span class="c1"></span></p><a id="t.7a3e6a2f8252fdd828a9c0c8b9a8b2691989cb33"></a><a id="t.1"></a><table class="c22"><tr class="c40"><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c17">// Fourth order sensor filter</span></p><p class="c4"><span class="c6">*angle1 = (*angle1) * 0.2 + olda1[0] * 0.2 + olda1[1] * 0.2 + olda1[2] * 0.2 + olda1[3] * 0.2;</span></p><p class="c4"><span class="c6">*angle2 = (*angle2) * 0.2 + olda2[0] * 0.2 + olda2[1] * 0.2 + olda2[2] * 0.2 + olda2[3] * 0.2;</span></p><p class="c4"><span class="c6">olda1[3] = olda1[2];</span></p><p class="c4"><span class="c6">olda1[2] = olda1[1];</span></p><p class="c4"><span class="c6">olda1[1] = olda1[0];</span></p><p class="c4"><span class="c6">olda1[0] = *angle1;</span></p><p class="c4"><span class="c6">olda2[3] = olda2[2];</span></p><p class="c4"><span class="c6">olda2[2] = olda2[1];</span></p><p class="c4"><span class="c6">olda2[1] = olda2[0];</span></p><p class="c4"><span class="c6">olda2[0] = *angle1;</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">From we can build I first order low pass filter to represent this in simulink suing the following formulas:</span></p><p class="c12"><img src="images/image3.png"></p><p class="c12"><img src="images/image4.png"></p><p class="c12 c19"><span class="c1"></span></p><p class="c15"><span class="c1">The controller dynamics of the filter are as shown in lecture:</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 157.00px; height: 76.01px;"><img alt="" src="images/image24.png" style="width: 157.00px; height: 99.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c3">Figure 7: Controller Dynamics in Simulink</span></p><p class="c12 c19"><span class="c3"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 499.50px; height: 359.42px;"><img alt="" src="images/image20.png" style="width: 499.50px; height: 359.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c3">Figure 8: Controller Dynamics before and after (blue -&gt; after)</span></p><h4 class="c0" id="h.ypg6n15eekp"><span class="c5">Derivative Filter</span></h4><p class="c15"><span class="c1">Once again we are using a finite impulse response (FIR) filter</span></p><p class="c11"><span class="c1"></span></p><a id="t.ae2ed5ef4faacffe4096dc73a0d266bc2ef6d84b"></a><a id="t.2"></a><table class="c22"><tr class="c40"><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c17">// fourth order derivative filter</span></p><p class="c4"><span class="c6">edot = edot * 0.2 + oldedot[0] * 0.2 + oldedot[1] * 0.2 + oldedot[2] * 0.2 + oldedot[3] * 0.2;</span></p><p class="c4"><span class="c6">oldedot[3] = oldedot[2];</span></p><p class="c4"><span class="c6">oldedot[2] = oldedot[1];</span></p><p class="c4"><span class="c6">oldedot[1] = oldedot[0];</span></p><p class="c4"><span class="c6">oldedot[0] = edot;</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><p class="c14"><span class="c5">And we use the below to model this in Simulink:</span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 177.49px; height: 83.38px;"><img alt="" src="images/image22.png" style="width: 177.49px; height: 102.49px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c59"><span class="c42">Figure 9: Derivative TF in Simulink</span></p><h4 class="c0" id="h.2qt7ddhe2h5f"><span class="c32 c5">10-Step Process</span></h4><p class="c15"><span class="c1">This process is very similar for both motors, so I will go through them both simultaneously and only explain my thinking in detail for motor one. One note, we completed steps 2-7 with the function cdes, which can be found in the appendix. </span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c3">Step 1: Identification of the System</span></p><p class="c15"><span class="c1">Using the models discussed above, we are representing our system as shown: </span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 230.67px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 230.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c3">Figure 10: Simulink System</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c3">Step 2: &nbsp;Find Phase X-Over Freq</span></p><p class="c15"><span class="c1">Executing the step2 inner function from the cdes function produces the following bode diagram.</span></p><p class="c11"><span class="c1"></span></p><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.3"></a><table class="c22"><tr class="c40"><td class="c47" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.00px; height: 241.33px;"><img alt="" src="images/image30.png" style="width: 298.00px; height: 241.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.00px; height: 245.33px;"><img alt="" src="images/image41.png" style="width: 298.00px; height: 245.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c12"><span class="c3">Figure 11: Bode Plots for Finding Phase Crossover Frequency (Motor 1 and 2, Respectively)</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">From this we can find that our initial zero for motor 1 is 1.5565 rad/s. Running the same function for motor two results in an initial zero of z2 = 5.9370 rad/s.</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c3">Step 3:</span></p><p class="c15"><span class="c1">Using standard standard kp, kd, ki and dynamics equations, the step 3 function runs and finds the following:</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">Motor 1:</span></p><p class="c15 c25"><span class="c1">kp = 1.2847</span></p><p class="c15 c25"><span class="c1">ki = 1</span></p><p class="c15 c25"><span class="c1">kd = 0.9975</span></p><p class="c15"><span class="c1">Dynamics:</span></p><p class="c15 c50"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 192.00px; height: 86.68px;"><img alt="" src="images/image33.png" style="width: 192.00px; height: 86.68px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c15"><span class="c1">Motor 2:</span></p><p class="c15 c25"><span class="c1">kp = 0.3367</span></p><p class="c15 c25"><span class="c1">ki = 1</span></p><p class="c15 c25"><span class="c1">kd = 0.0283</span></p><p class="c15"><span class="c1">Dynamics:</span></p><p class="c15 c50"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 192.00px; height: 80.13px;"><img alt="" src="images/image38.png" style="width: 192.00px; height: 80.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c3">Step 4: Find New Phase X-Over Freq</span></p><p class="c15"><span class="c1">We recomputed the dynamics, found the new zero and repeated this 20 times with the step4 function in cdes. The resulting values:</span></p><p class="c15"><span class="c1">Motor1:</span></p><p class="c15 c25"><span class="c1">kp4 = 2.2335</span></p><p class="c15 c25"><span class="c1">ki4 = 1</span></p><p class="c15 c25"><span class="c1">kd4 = 1.2469</span></p><p class="c15"><span class="c1">Dynamics:</span></p><p class="c15 c50"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 192.00px; height: 73.09px;"><img alt="" src="images/image13.png" style="width: 192.00px; height: 73.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c15"><span class="c1">Motor2:</span></p><p class="c15 c25"><span class="c1">kp4 = 0.1971</span></p><p class="c15 c25"><span class="c1">ki4 = 1</span></p><p class="c15 c25"><span class="c1">kd4 = 0.0097</span></p><p class="c15"><span class="c1">Dynamics:</span></p><p class="c15 c50"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 192.00px; height: 80.00px;"><img alt="" src="images/image32.png" style="width: 192.00px; height: 80.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c11"><span class="c1"></span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c42">Step 5: Initial Gain K</span></p><p class="c15"><span class="c1">We can compute the initial gian with the margin function and the values found in step4</span></p><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.4"></a><table class="c24"><tr class="c40"><td class="c47" colspan="1" rowspan="1"><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.00px; height: 248.00px;"><img alt="" src="images/image35.png" style="width: 298.00px; height: 248.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.00px; height: 249.33px;"><img alt="" src="images/image40.png" style="width: 298.00px; height: 249.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c12"><span class="c3">Figure 12. Root Locus of Motor 1 (Left) and Motor 2 (Right) Open-Loop Transfer Function </span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">Initial Gain is&hellip;</span></p><p class="c15"><span class="c1">Motor1:</span></p><p class="c15 c50"><span class="c1">k = 2.7191</span></p><p class="c15"><span class="c1">Motor 2:</span></p><p class="c15 c50"><span class="c1">k = &nbsp;17.5274</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c42">Step 6: Check Result</span></p><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.5"></a><table class="c22"><tr class="c40"><td class="c47" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.00px; height: 270.67px;"><img alt="" src="images/image31.png" style="width: 298.00px; height: 270.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 289.50px; height: 292.74px;"><img alt="" src="images/image26.png" style="width: 289.50px; height: 292.74px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c12"><span class="c3">Figure 13: Nyqlog Plots; Motor 1</span></p><p class="c15"><span class="c1">We can observe by comparing the nyqlog plots with and without k that the corner moves nearer to the odB line as desired. Phase margin is also improved. The same can be observed for motor 2:</span></p><p class="c11"><span class="c1"></span></p><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.6"></a><table class="c22"><tr class="c40"><td class="c47" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.00px; height: 298.67px;"><img alt="" src="images/image10.png" style="width: 298.00px; height: 298.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 285.50px; height: 294.02px;"><img alt="" src="images/image21.png" style="width: 285.50px; height: 294.02px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c12"><span class="c42">Figure 14: Nyqlog Plots; Motor 2</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c3">Step 7: Step Response</span></p><p class="c15"><span class="c1">Using step 7 in the CDEs function, let&#39;s generate three step responses optimizing for different qualities&ndash;overshoot (kos), settle time(kts) and steady-state error(kes).</span></p><p class="c11"><span class="c1"></span></p><p class="c11"><span class="c1"></span></p><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.7"></a><table class="c22"><tr class="c40"><td class="c47" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.00px; height: 233.33px;"><img alt="" src="images/image23.png" style="width: 298.00px; height: 233.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.00px; height: 237.33px;"><img alt="" src="images/image17.png" style="width: 298.00px; height: 237.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c12"><span class="c3">Figure 15: Step Responses for Motors 1 and 2, Respectively</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">Since we&#39;re both concerned about the speed and overshoot of our arm, let&#39;s use the ktos step responses as a basis before we begin heuristically tuning with non-linearities added to the system. </span></p><h4 class="c0" id="h.581b4n1l5bcl"><span class="c32 c5">Heuristic Tuning</span></h4><p class="c15"><span class="c1">The below is our simulink system with nonlinearities considered.</span></p><p class="c15"><span class="c1">Besides simulationx we considered the following non-linearities:</span></p><ul class="c27 lst-kix_ku1xnn35ty4-0 start"><li class="c15 c25 c28 li-bullet-0"><span class="c1">Discrete signal of PID</span></li></ul><ul class="c27 lst-kix_ku1xnn35ty4-1 start"><li class="c15 c28 c64 li-bullet-0"><span class="c1">Added zero hold block after pid. Holds for the time between ISR executions (1/CF)</span></li></ul><ul class="c27 lst-kix_ku1xnn35ty4-0"><li class="c15 c25 c28 li-bullet-0"><span class="c1">Voltage limit of microcontroller (approximately 3.3V)</span></li></ul><ul class="c27 lst-kix_ku1xnn35ty4-1 start"><li class="c15 c64 c28 li-bullet-0"><span class="c1">Added a saturation block after PID</span></li></ul><ul class="c27 lst-kix_ku1xnn35ty4-0"><li class="c15 c25 c28 li-bullet-0"><span class="c1">Voltage limit of amplifier</span></li></ul><ul class="c27 lst-kix_ku1xnn35ty4-1 start"><li class="c15 c64 c28 li-bullet-0"><span class="c1">There are electronics preventing the amplifier from exceeding 15 volts</span></li><li class="c15 c64 c28 li-bullet-0"><span class="c1">Added saturation block after amplifier</span></li></ul><ul class="c27 lst-kix_ku1xnn35ty4-0"><li class="c15 c25 c28 li-bullet-0"><span class="c1">Floor or ceiling block</span></li></ul><ul class="c27 lst-kix_ku1xnn35ty4-1 start"><li class="c15 c64 c28 li-bullet-0"><span class="c1">As explained in the sensor model design section, a floor or ceiling block is required since the microcontroller receives whole values</span></li></ul><p class="c11"><span class="c1"></span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 228.00px;"><img alt="" src="images/image36.png" style="width: 624.00px; height: 228.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c42">Figure 16: Simulink System with Co-Simulation Block Connected</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c3">Tuning:</span></p><p class="c15"><span class="c1">We notice that it&#39;s much more difficult to get a successful simulation with all these added nonlinearities. Normally the amplifier acted as sort of low pass filter to smooth out the PWM data from the PID, however with all these added nonlinearities the output of the amplifier remains unsmooth:</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 576.00px; height: 262.30px;"><img alt="" src="images/image9.png" style="width: 576.00px; height: 262.30px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c3">Figure 17: Unfiltered Amplifier Output Voltage</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">To prevent this from impairing the model of our system, we&#39;ve added a basic lowpass filter, and adjusted the cutoff frequency until the system reacted appropriately.</span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 576.00px; height: 222.42px;"><img alt="" src="images/image19.png" style="width: 576.00px; height: 222.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c42">Figure 18: Filtered Amplifier Output Voltage</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">I also noticed that the system was overshooting overall, and observed that since we were flooring the sensor data, the error being sent through the feedback was less than it should have been. In an attempt to correct this, I opted to use the ceiling block instead (switching to this representation in code would be very simple) and it corrected a good portion of the overshoot.</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 434.88px;"><img alt="" src="images/image37.png" style="width: 384.00px; height: 434.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c42">Figure 19: SimulationX Co-Simulation Output </span><span class="c42 c63">(positions are in red and yellow, speeds in blue and green) </span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">Eventually tuned to work fairly well. Both angles were set to settle at &pi;/16. The largest overshoot is less than 1 percent, satisfying our Percentage Overshoot RCG.</span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 360.89px; height: 283.33px;"><img alt="" src="images/image34.png" style="width: 360.89px; height: 283.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c12"><span class="c42">Figure 20: Path Traced by the SCARA (in meters)</span></p><h3 class="c65" id="h.s0dvmgz3jcs4"><span class="c5">Actuator Design</span></h3><p class="c15"><span class="c42">Table 2: Actuator RCGs</span></p><a id="t.967948f799fea9278a24e3c793e9f84a51775cc5"></a><a id="t.8"></a><table class="c24"><tr class="c40"><td class="c37 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Property</span></p></td><td class="c30 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Requirement</span></p></td><td class="c30 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Constraint</span></p></td><td class="c30 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Goal</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c9"><span class="c1">Stall Torque</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&gt; 3.5 Nm</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&gt; 35 Nm</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c9"><span class="c1">Speed</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&gt; 3 rad/s</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c9"><span class="c1">Encoder Resolution (CPR)</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">1024</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c5">For our actuators, we picked the BAG Motor</span><span class="c5 c39">1</span><span class="c5">&nbsp;mounted to a Versaplanetary 100:1 gearbox</span><span class="c5 c39">2</span><span class="c5">, with a Versaplanetary integrated encoder</span><span class="c5 c39">3</span><span class="c1">.</span></p><p class="c11"><span class="c1"></span></p><a id="t.bac3ca795044c68819e1589b157e1d2dd68d9e1b"></a><a id="t.9"></a><table class="c55 c71"><thead><tr class="c40"><td class="c48" colspan="1" rowspan="1"><p class="c9"><span class="c5">BAG Motor</span></p></td><td class="c77" colspan="1" rowspan="1"><p class="c4"><span class="c5">V</span><span class="c5 c13">nominal</span><span class="c5">&nbsp;=</span><span class="c1">&nbsp;12V DC</span></p><p class="c4"><span class="c5">&Omega;</span><span class="c5 c13">no load</span><span class="c5">&nbsp;=</span><span class="c1">&nbsp;13,180 rpm</span></p><p class="c4"><span class="c5">I</span><span class="c5 c13">no load</span><span class="c5">&nbsp;=</span><span class="c1">&nbsp;1.8A</span></p><p class="c4"><span class="c5">P</span><span class="c5 c13">max</span><span class="c1">&nbsp;= 149 W</span></p><p class="c4"><span class="c5">&tau;</span><span class="c5 c13">stall</span><span class="c5">&nbsp;=</span><span class="c1">&nbsp;0.4 N-m</span></p><p class="c4"><span class="c5">I</span><span class="c5 c13">stall</span><span class="c5">&nbsp;=</span><span class="c1">&nbsp;53A</span></p></td><td class="c56" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 144.50px; height: 124.97px;"><img alt="" src="images/image12.png" style="width: 144.50px; height: 124.97px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c40"><td class="c48" colspan="1" rowspan="1"><p class="c9"><span class="c5">VersaPlanetary Gearbox v2</span></p></td><td class="c77" colspan="1" rowspan="1"><p class="c4"><span class="c42">Stage:</span><span class="c1">&nbsp;Single Stage</span></p><p class="c4"><span class="c42">Gear Ratio:</span><span class="c1">&nbsp;100:1</span></p><p class="c4"><span class="c42">Shaft:</span><span class="c1">&nbsp;&frac12;&rdquo; Hex</span></p><p class="c4"><span class="c42">Encoder:</span><span class="c1">&nbsp;Integrated </span></p></td><td class="c56" colspan="1" rowspan="1"><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 148.00px; height: 107.74px;"><img alt="" src="images/image28.png" style="width: 148.00px; height: 107.74px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></thead></table><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c5">The main criteria that influenced our decision: we wanted it to be inexpensive (accessibility), easy to assemble and mount (simplicity), have sufficient torque (enough to move the arm, with a safety factor of 10), and sufficient speed (say, &gt; 3 rad/s). For information about the encoder resolution can be found in the </span><span class="c5 c29">Hardware</span><span class="c1">&nbsp;report. </span></p><p class="c11"><span class="c1"></span></p><p class="c14"><span class="c5">We needed to d</span><span class="c5">etermine the motor parameters left implicit in the datasheet &ndash; R, L, K</span><span class="c5 c13">M</span><span class="c1">, the Js and the Bs &ndash; in order to construct our transfer functions. We did so in the following way:</span></p><p class="c15 c25"><span class="c3">Resistance R</span></p><p class="c14 c25"><span class="c5">The resistance was calculated using the following formula: R = V</span><span class="c5 c13">nominal</span><span class="c5">&nbsp;/ </span><span class="c5">I</span><span class="c5 c13">stall</span><span class="c5">&nbsp;= </span><span class="c66 c5">0.2264 </span><span class="c2">&Omega;</span><span class="c36 c5 c45 c8">.</span></p><p class="c15 c25"><span class="c31 c8">Inductance L</span></p><p class="c15 c25"><span class="c5 c8">A representative sample of motors was sampled from the Maxon catalog, and the relationship between their resistances and inductances was plotted. The relationship was observed to be approximately linear. Performing a linear regression and plugging in our calculated R, we get </span><span class="c5 c8">L = </span><span class="c2">0.059155 mH</span><span class="c36 c5 c45 c8">.</span></p><p class="c59 c25"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 420.50px; height: 259.44px;"><img alt="" src="images/image29.png" style="width: 420.50px; height: 259.44px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title="Chart"></span></p><p class="c25 c59"><span class="c31 c8">Figure 21: Inductance vs Resistance Plot for 10 Maxon Motors</span></p><p class="c12 c19 c25"><span class="c31 c8"></span></p><p class="c15 c25"><span class="c42 c8">Motor Constant K</span><span class="c13 c8 c42">M</span></p><p class="c14 c25"><span class="c5 c8">Similarly, plotting torque vs current from the provided BAG motor data</span><span class="c5 c39 c8">4</span><span class="c5 c8">, we perform a linear regression. The slope of the line is our motor constant; K</span><span class="c5 c13 c8">M</span><span class="c5 c8">&nbsp;= </span><span class="c2">0.008474576271 Nm/A</span><span class="c36 c5 c45 c8">. </span></p><p class="c15 c25"><span class="c31 c8">Js</span></p><p class="c14 c25"><span class="c5 c8">Inertias of the motor and gearbox were taken from the solidworks models, after inputting the appropriate material information. The inertia of the Head and Head + Arm assemblies was determined in a similar way. After that, they were combined into two comprehensive Js for each respective motor, using the formula J = i</span><span class="c5 c39 c8">2</span><span class="c5 c8">&sdot;</span><span class="c5 c8">(</span><span class="c5 c8">J</span><span class="c5 c13 c8">motor</span><span class="c5 c8">&nbsp;+ </span><span class="c5 c8">J</span><span class="c5 c13 c8">pinion</span><span class="c5 c8">) + J</span><span class="c5 c8 c13">gear</span><span class="c5 c8">&nbsp;+ J</span><span class="c5 c13 c8">load</span><span class="c5 c8">&nbsp;where </span><span class="c5 c29 c8">i</span><span class="c5 c8">&nbsp;is the gear ratio. J</span><span class="c5 c13 c8">Head</span><span class="c5 c8">&nbsp;= </span><span class="c2">33015120</span><span class="c66 c5">&sdot;</span><span class="c2">10</span><span class="c5 c39 c8">&ndash;9</span><span class="c2">&nbsp;kgm</span><span class="c5 c39 c8">2</span><span class="c5 c8">&nbsp;</span><span class="c5 c8">and J</span><span class="c5 c13 c8">Arm + Head</span><span class="c5 c8">&nbsp;= </span><span class="c2">2574181465</span><span class="c5 c66">&sdot;</span><span class="c2">10</span><span class="c5 c39 c8">&ndash;9</span><span class="c2">&nbsp;kgm</span><span class="c5 c39 c8">2</span><span class="c36 c5 c45 c8">.</span></p><p class="c15 c25"><span class="c8 c31">Bs</span></p><p class="c14 c25"><span class="c5 c8">The Bs were determined in the following way: </span><span class="c5 c8">B</span><span class="c5 c13 c8">motor</span><span class="c5 c8">&nbsp;= </span><span class="c5 c8">V</span><span class="c5 c13 c8">nominal</span><span class="c5 c8">&nbsp;&sdot; I</span><span class="c5 c13 c8">no</span><span class="c5 c13 c8">&nbsp;load</span><span class="c5 c8">&nbsp;/ (</span><span class="c5 c8">V</span><span class="c5 c13 c8">nominal</span><span class="c5 c8">/K</span><span class="c5 c13 c8">M</span><span class="c5 c8">)</span><span class="c5 c39 c8">2</span><span class="c5 c8">; </span><span class="c5 c8">B</span><span class="c5 c13 c8">t</span><span class="c5 c13 c8">ooth</span><span class="c5 c8">&nbsp;= efficiency &sdot; </span><span class="c5">&tau;</span><span class="c5 c13 c8">nominal</span><span class="c5 c8">&nbsp;/ </span><span class="c5">&omega;</span><span class="c5 c13 c8">nominal</span><span class="c5 c8">; B</span><span class="c5 c13 c8">gear</span><span class="c5 c8">&nbsp;= 7&sdot;10</span><span class="c5 c39 c8">&ndash;4</span><span class="c5 c8">&nbsp;kg/s, assuming blown bearings and finally B = i</span><span class="c5 c39 c8">2</span><span class="c5 c8">&sdot;(B</span><span class="c5 c13 c8">motor</span><span class="c5 c8">&nbsp;+ B</span><span class="c5 c13 c8">tooth</span><span class="c5 c8">) + B</span><span class="c5 c13 c8">gear</span><span class="c5 c8">&nbsp;where </span><span class="c5 c29 c8">i</span><span class="c36 c5 c45 c8">&nbsp;is the gear ratio. B = 0.5130 kg/s.</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c5">Since &tau; = B&omega;, the torque required to move the SCARA was calculated by plugging in our B value, calculated above, along with the minimum speed as indicated in our RCGs. &tau; = </span><span class="c5 c8">0.5130 &sdot; 3 = 1.5 Nm. With a safety factor of 10, </span><span class="c5">&tau; = 15 Nm. Since the stall torque of the BAG Motor is 0.4 (40 with a 100:1 gearbox), a 100:1 gear ratio suffices whereas, say, a 10:1 would not. </span></p><h3 class="c65" id="h.ts3vfealse2h"><span class="c36 c57 c5">Code</span></h3><p class="c15"><span class="c42">Table 3: Code RCGs</span></p><a id="t.7901572943dde3009129e318158fa3d1e4d00090"></a><a id="t.10"></a><table class="c24"><tr class="c40"><td class="c37 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Property</span></p></td><td class="c30 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Requirement</span></p></td><td class="c30 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Constraint</span></p></td><td class="c30 c35" colspan="1" rowspan="1"><p class="c9"><span class="c26">Goal</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c9"><span class="c1">Control Frequency</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&gt;1kHz</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c9"><span class="c1">FIlter order</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&gt;3</span></p></td></tr><tr class="c40"><td class="c37" colspan="1" rowspan="1"><p class="c9"><span class="c1">Code size</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&lt;4MB</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ndash;</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c9"><span class="c1">&lt;1MB Without xy data</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><h4 class="c0" id="h.gomn93q0pp5g"><span class="c32 c5">Homing Logic:</span></h4><p class="c15"><span class="c36 c62 c45">We check the sensor value. If both read less than 20 centimeters then we are homed and can proceed. Otherwise we wait. See code below:</span></p><p class="c11"><span class="c1"></span></p><a id="t.11fe2144c0e44401f6b9260566bcdbfd680057e3"></a><a id="t.11"></a><table class="c22"><tr class="c40"><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c43">&nbsp; &nbsp; // </span><span class="c10 c63 c72"><a class="c33" href="https://www.google.com/url?q=https://howtomechatronics.com/tutorials/arduino/ultrasonic-sensor-hc-sr04/&amp;sa=D&amp;source=editors&amp;ust=1695524917295929&amp;usg=AOvVaw3J_6I9KTqEhHmFjKl6l1BN">https://howtomechatronics.com/tutorials/arduino/ultrasonic-sensor-hc-sr04/</a></span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // The above link was a very useful resource in developing this code</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; long duration1;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; float distance1;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; long duration2;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; float distance2;</span></p><p class="c4"><span class="c17">&nbsp;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; //if distance is less than 20 centimeter for both sensors then we are homed</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; while (distance1 &lt; 0.2 || distance2 &lt; 2)</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; {</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;Clears the trigPin</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; digitalWrite(TRIG1, LOW);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; delayMicroseconds(2);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; // Sets the trigPin on HIGH state for 10 micro seconds</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; digitalWrite(TRIG1, HIGH);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; delayMicroseconds(10);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; digitalWrite(TRIG1, LOW);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; // Reads the echoPin, returns the sound wave travel time in microseconds</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; duration1 = pulseIn(ECHO1, HIGH);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; // Calculating the distance</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; distance1 = duration1 * 0.034 / 2.0;</span></p><p class="c4"><span class="c17">&nbsp;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; // Clears the trigPin</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; digitalWrite(TRIG2, LOW);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; delayMicroseconds(2);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; // Sets the trigPin on HIGH state for 10 micro seconds</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; digitalWrite(TRIG2, HIGH);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; delayMicroseconds(10);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; digitalWrite(TRIG2, LOW);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; // Reads the echoPin, returns the sound wave travel time in microseconds</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; duration2 = pulseIn(ECHO1, HIGH);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; // Calculating the distance</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; distance2 = duration2 * 0.034 / 2.0;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // set counters to zero(home)</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; counter1 = 0;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; counter1 = 0;</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><h4 class="c0" id="h.ve8anxdx1nz4"><span class="c32 c5">Sensor Logic</span></h4><p class="c15"><span class="c1">We are interfacing with a 4 bit counter and a 1024 resolution encoder for this build. </span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">Our sensor logic procedure is as follow:</span></p><ul class="c27 lst-kix_yxr45t4lxl7e-0 start"><li class="c15 c25 c28 li-bullet-0"><span class="c1">Read from carry and borrow pins</span></li><li class="c15 c25 c28 li-bullet-0"><span class="c1">If read is one, increment count by 16. if borrow bit is one, subtract 16 to counter</span></li><li class="c15 c25 c28 li-bullet-0"><span class="c1">If the counter is greater than or equal to resolution(ie. It has completed a full rotation), subtract 1024 from counter (using modulo)</span></li><li class="c15 c25 c28 li-bullet-0"><span class="c1">Read values from the 4 1 bit sensor pins</span></li><li class="c15 c25 c28 li-bullet-0"><span class="c1">Shift and mask values appropriate to find current 4 bit sensor value</span></li><li class="c15 c25 c28 li-bullet-0"><span class="c1">The current angle is the sum of the 4 bit sensor value, and the count</span></li></ul><p class="c11"><span class="c1"></span></p><a id="t.6b122788b34736c4cc7da08a868d0e9436995ce2"></a><a id="t.12"></a><table class="c22"><tr class="c40"><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c17">/*</span></p><p class="c4"><span class="c17">&nbsp;* read from sensors and update angles and counters accordingly</span></p><p class="c4"><span class="c17">&nbsp;* PARAM: &nbsp; &nbsp; pointer to counter for motor 1</span></p><p class="c4"><span class="c17">&nbsp;* PARAM: &nbsp; &nbsp; pointer to angle for motor 1</span></p><p class="c4"><span class="c17">&nbsp;* PARAM: &nbsp; &nbsp; pointer to counter for motor 2</span></p><p class="c4"><span class="c17">&nbsp;* PARAM: &nbsp; &nbsp; pointer to angle for motor 2</span></p><p class="c4"><span class="c17">&nbsp;* PRE: &nbsp; &nbsp; &nbsp; each argument is a valid pointer and is already allocated memory for one integer</span></p><p class="c4"><span class="c17">&nbsp;* Post: &nbsp; &nbsp; &nbsp;counter1, angle1, counter2, and angle2 are updated with new values interpreted from sensor reads</span></p><p class="c4"><span class="c17">&nbsp;* RETURN: &nbsp; &nbsp;VOID</span></p><p class="c4"><span class="c17">&nbsp;*/</span></p><p class="c4"><span class="c17">void readSensors(int *counter1, int *angle1, int *counter2, int *angle2)</span></p><p class="c4"><span class="c17">{</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; char carry = digitalRead(carry1); &nbsp; // carry bit</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; char borrow = digitalRead(borrow1); // borrow bit</span></p><p class="c4"><span class="c17">&nbsp;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // if borrow bit is one, subtract 16 to counter</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // if carry bit is one, add 16 to counter</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *counter1 += (carry - borrow) * 16;</span></p><p class="c4"><span class="c17">&nbsp;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // when motor completes rotation, counter will exceed resolution</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *counter1 = *counter1 % res; // this will subtract res from any counter &gt;= res &nbsp;</span></p><p class="c4"><span class="c17">&nbsp;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // encoder for motor 1</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle1 = digitalRead(e1Pin4); // least significant bit</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle1 |= digitalRead(e1Pin3) &lt;&lt; 1;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle1 |= digitalRead(e1Pin2) &lt;&lt; 2;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle1 |= digitalRead(e1Pin1) &lt;&lt; 3; // most significant bit</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle1 += *counter1;</span></p><p class="c4"><span class="c17">&nbsp;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; carry = digitalRead(carry2); &nbsp; // carry bit</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; borrow = digitalRead(borrow2); // borrow bit</span></p><p class="c4"><span class="c17">&nbsp;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // if borrow bit is one, subtract 16 to counter</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // if carry bit is one, add 16 to counter</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *counter2 += (carry - borrow) * 16;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *counter2 = *counter2 % res;</span></p><p class="c4"><span class="c17">&nbsp;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // encoder digits for second motor</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle2 = digitalRead(e1Pin4); // least significant bit</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle2 |= digitalRead(e1Pin3) &lt;&lt; 1;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle2 |= digitalRead(e1Pin2) &lt;&lt; 2;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle2 |= digitalRead(e1Pin1) &lt;&lt; 3; // most significant bit</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle2 += *counter2;</span></p><p class="c4"><span class="c17">&nbsp;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; // Fourth order sensor filter</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle1 = (*angle1) * 0.2 + olda1[0] * 0.2 + olda1[1] * 0.2 + olda1[2] * 0.2 + olda1[3] * 0.2;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; *angle2 = (*angle2) * 0.2 + olda2[0] * 0.2 + olda2[1] * 0.2 + olda2[2] * 0.2 + olda2[3] * 0.2;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; olda1[3] = olda1[2];</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; olda1[2] = olda1[1];</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; olda1[1] = olda1[0];</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; olda1[0] = *angle1;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; olda2[3] = olda2[2];</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; olda2[2] = olda2[1];</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; olda2[1] = olda2[0];</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; olda2[0] = *angle1;</span></p><p class="c4"><span class="c17">}</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><h4 class="c0" id="h.2xru8hvmsgav"><span class="c32 c5">Kinematics</span></h4><p class="c15"><span class="c1">Inverse and forward kinematics are being applied in our build to convert from xy coordinates to angles, and from angles back to xy coordinates.</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 288.00px; height: 219.84px;"><img alt="" src="images/image11.png" style="width: 288.00px; height: 219.84px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c59 c25"><span class="c42 c8">Figure 22: Inverse Kinematics Diagram</span></p><p class="c15"><span class="c1">We can easily find a formula for forward kinematics using basic trigonometry</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><img src="images/image5.png"></p><p class="c12"><img src="images/image6.png"></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">The inverse kinematics formula is more complicated, in the first quadrant we can compute it using cosine and sine law and find the following:</span></p><p class="c11"><span class="c1"></span></p><p class="c12"><img src="images/image7.png"><span class="c5"><br></span><img src="images/image8.png"></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">Inverse kinematics becomes even more complicated when considering multiple quadrants, and optimizing for nearest angle(ie. Rotating to negative ten degrees instead of positive 350 degrees). Fortunately we discovered several useful references online walking through trigonometry[5] and ideal angles per quadrant [5]. &nbsp;From these, we formulated the matlab and c functions available in the appendix.</span></p><p class="c15"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p><a id="t.068e27bfb7e58f12793b01bc6c48511e064dfa49"></a><a id="t.13"></a><table class="c22"><tr class="c40"><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c17">/*</span></p><p class="c4"><span class="c17">&nbsp;* Convert arm angles to xy coordinate</span></p><p class="c4"><span class="c17">&nbsp;* PARAM: &nbsp; &nbsp; float for angle between vertical axis and arm 1 (positive angle in clockwise direction)</span></p><p class="c4"><span class="c17">&nbsp;* PARAM: &nbsp; &nbsp; float for angle between arm1 and arm2 (positive angle when arm2 is is more clockwise than arm 1)</span></p><p class="c4"><span class="c17">&nbsp;* PRE: &nbsp; &nbsp; &nbsp; xy is a valid pointer and is already allocated memory for two floats</span></p><p class="c4"><span class="c17">&nbsp;* Post: &nbsp; &nbsp; &nbsp;xy points to an array of two floats, with the first element containing the x coordinate</span></p><p class="c4"><span class="c17">&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and the second containing the y coordinate</span></p><p class="c4"><span class="c17">&nbsp;* RETURN: &nbsp; &nbsp;VOID</span></p><p class="c4"><span class="c17">&nbsp;* ATTRIBUTION: This code was with reference to the following two sources</span></p><p class="c4"><span class="c17">&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- https://howtomechatronics.com/projects/scara-robot-how-to-build-your-own-arduino-based-robot/</span></p><p class="c4"><span class="c17">&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- https://robotacademy.net.au/lesson/inverse-kinematics-for-a-2-joint-robot-arm-using-geometry/?fbclid=IwAR1dexD-6qJSMt2P9hVNzZhVUVJWzsUyGeMKlYZBgkTWxj0W2RKYrFDkPgM</span></p><p class="c4"><span class="c17">&nbsp;*/</span></p><p class="c4 c19"><span class="c17"></span></p><p class="c4"><span class="c17">void forwardKinematics(float a1, float a2, float *xy)</span></p><p class="c4"><span class="c17">{</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; xy[0] = L1 * cos(a1) + L2 * cos(a1 + a2);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; xy[1] = L1 * sin(a1) + L2 * sin(a1 + a2);</span></p><p class="c4"><span class="c17">}</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><h4 class="c0" id="h.1h1m5nak3g7k"><span class="c32 c5">Path Planning</span></h4><p class="c15"><span class="c1">Our poth planning is time based. We adjust to the next value based on the internal clock of the microcontroller. This was chosen instead of an error based approach since our application does not require extreme precision and a time based method has a more predictable speed.</span></p><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">Circular path planning</span></p><a id="t.b6ec80f8f0fd500eafdbaf718c2d4b36df8530dc"></a><a id="t.14"></a><table class="c22"><tr class="c40"><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c16">function </span><span class="c46 c36">a1 = fcn(t)</span></p><p class="c4"><span class="c16">persistent </span><span class="c46 c36">lastTime;</span></p><p class="c4"><span class="c16">if</span><span class="c46 c36">(isempty(lastTime))</span></p><p class="c4"><span class="c46 c36">&nbsp; &nbsp;lastTime = t;</span></p><p class="c4"><span class="c16 c36">end</span></p><p class="c4"><span class="c16">if</span><span class="c46 c36">((t&gt;lastTime+0.1))</span></p><p class="c4"><span class="c46 c36">&nbsp; &nbsp; lastTime = t;</span></p><p class="c4"><span class="c16 c36">end</span></p><p class="c4"><span class="c68">a1 = t*pi/2; </span><span class="c67">%complete loop in 4 seconds</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">Back and forth path planning</span></p><a id="t.9942bfb1e2a0717aeb2a8c563d55c6732db7c77a"></a><a id="t.15"></a><table class="c22"><tr class="c40"><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c16">function </span><span class="c36 c46">a2 = fcn(t)</span></p><p class="c4"><span class="c16">if</span><span class="c68">(mod(floor(t), 2)==0) </span><span class="c67 c36">%if even</span></p><p class="c4"><span class="c46 c36">&nbsp; &nbsp; a2 = pi/6;</span></p><p class="c4"><span class="c16 c36">else</span></p><p class="c4"><span class="c46 c36">&nbsp; &nbsp;a2 = 0;</span></p><p class="c4"><span class="c16">end</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><p class="c15"><span class="c1">C-code Path planning</span></p><a id="t.180b6676cd53123796c9128b1438bf06778ece52"></a><a id="t.16"></a><table class="c22"><tr class="c40"><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c17">/*</span></p><p class="c4"><span class="c17">&nbsp;* update path values every pathUpdateTime microseconds</span></p><p class="c4"><span class="c17">&nbsp;* PARAM: &nbsp; &nbsp; unsigned long pointer for time since last update</span></p><p class="c4"><span class="c17">&nbsp;* PARAM: &nbsp; &nbsp; integer pointer float for angle between arm1 and arm2 (positive angle when arm2 is is more clockwise than arm 1)</span></p><p class="c4"><span class="c17">&nbsp;* PRE: &nbsp; &nbsp; &nbsp; pointI is a valid pointer and is already allocated memory for one integer</span></p><p class="c4"><span class="c17">&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;time is a valid pointer and is already allocated memory for one unsigned long</span></p><p class="c4"><span class="c17">&nbsp;* Post: &nbsp; &nbsp; &nbsp;if the update occurs, time holds current timer value and pointI is incremented by 1</span></p><p class="c4"><span class="c17">&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;otherwise, no changes</span></p><p class="c4"><span class="c17">&nbsp;* RETURN: &nbsp; &nbsp;VOID</span></p><p class="c4"><span class="c17">&nbsp;*/</span></p><p class="c4"><span class="c17">void pathPlanning(unsigned long *time, int *pointI)</span></p><p class="c4"><span class="c17">{</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; if ((micros() - *time) &gt; pathUpdateTime)</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; {</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; *time = micros();</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; if (size &lt;= (*pointI + 1))</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit(0);</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; (*pointI)++;</span></p><p class="c4"><span class="c17">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c17">}</span></p></td></tr></table><p class="c11"><span class="c1"></span></p><h4 class="c0" id="h.6wekgcczbt8u"><span class="c5 c32">Self-Documentation</span></h4><p class="c15"><span class="c1">Our code is thoroughly commented, and designed to be easy to understand. Please see the appendix for a file </span></p><h4 class="c0" id="h.gmavmdei0vrc"><span class="c32 c5">Testing</span></h4><p class="c15"><span class="c1">We utilized several testing methods:</span></p><ol class="c27 lst-kix_51oa0yjksxqn-0 start" start="1"><li class="c15 c25 c28 li-bullet-0"><span class="c5">Running code in </span><span class="c5">Wokwi</span><span class="c1">&nbsp;ESP 32 simulator verified that code could run on device</span></li><li class="c15 c25 c28 li-bullet-0"><span class="c1">Run code in simulink/matlab where possible to test its validity. </span></li><li class="c15 c25 c28 li-bullet-0"><span class="c1">Tested inverse and forward kinematics functions with known values to ensure functionality</span></li></ol><h2 class="c61" id="h.h1ttglahnbly"><span class="c36 c54">References:</span></h2><ol class="c27 lst-kix_vjacn8cef30-0 start" start="1"><li class="c25 c28 c52 li-bullet-0"><span class="c5">&ldquo;BAG Motor.&rdquo; </span><span class="c5 c29">VEX Robotics</span><span class="c1">, www.vexrobotics.com/217-3351.html.</span></li><li class="c52 c25 c28 li-bullet-0"><span class="c5">&ldquo;VersaPlanetary Gearbox.&rdquo; </span><span class="c5 c29">VEX Robotics</span><span class="c1">, www.vexrobotics.com/versaplanetary.html.</span></li><li class="c52 c25 c28 li-bullet-0"><span class="c5">&ldquo;VersaPlanetary Integrated Encoder.&rdquo; </span><span class="c5 c29">VEX Robotics</span><span class="c1">, www.vexrobotics.com/217-5046.html.</span></li><li class="c52 c25 c28 li-bullet-0"><span class="c5">&ldquo;BAG Motor - VEXpro Motors - VEX Robotics.&rdquo; </span><span class="c5 c29">Motors</span><span class="c1">, motors.vex.com/vexpro-motors/bag-motor.</span></li><li class="c52 c25 c28 li-bullet-0"><span class="c5">&ldquo;SCARA Robot | How To Build Your Own Arduino Based Robot.&rdquo; </span><span class="c5 c29">How To Mechatronics</span><span class="c5">, </span><span class="c10 c74"><a class="c33" href="https://www.google.com/url?q=https://howtomechatronics.com/projects/scara-robot-how-to-build-your-own-arduino-based-robot/&amp;sa=D&amp;source=editors&amp;ust=1695524917539910&amp;usg=AOvVaw31bj__GWBiBFnh_2-hAxQm">https://howtomechatronics.com/projects/scara-robot-how-to-build-your-own-arduino-based-robot/</a></span><span class="c5">. </span></li></ol><h2 class="c61" id="h.rwontong3yw6"><span class="c36 c5 c60">Appendix: </span></h2><p class="c15"><span class="c29">Redacted</span></p><div><p class="c19 c20"><span class="c1"></span></p></div></body></html>